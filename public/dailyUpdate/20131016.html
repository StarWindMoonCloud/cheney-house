<!DOCUMENTTYPE html>
<html>
	<head>
		<title>Oct 13, 2013</title>
	</head>
	<body>
		<ol>
			<li>
				Leetcode refinement
				<ul>
					<li>   Longest Valid Parentheses 
						<pre>
(()
)()())

valid: number of ( and ) are same

naive method
check all length: O(n^2), from longest to shortest

count
): -1; (: 1

from right to left find matching: O(n^2) for worst case

Refinement
with statck (sacrifice space for time)
keep track of non-matching '('

for the current char
1. '('
push to stack
2. ')'
a. !s.empty()
top, compute, update, pop
b. empty()
skip

Points of attention
push index instead of value
length: i-j+1
pay attention to continuous two sections
keep track of last non-matched ')' instead of last ')', which would correctly handle "()(())" case
</pre>
					</li>
					<li>   Search Insert Position
						<pre>
int searchInsert(int A[], int n, int target) {
[1,3,5,6], 5 → 2
[1,3,5,6], 2 → 1
[1,3,5,6], 7 → 4
[1,3,5,6], 0 → 0

naive search
from left to right
for (int i = 0; i < n; i++) {
if (A[i] >= target) return i;
}
return i

binary search
Points of attention
still need to compare with target when meet termination condition (start >= end)

int searchBinary(int A[], int start, int end, int target) { searchBinary(A, 0, 0, 2), searchBinary(A, 2, 3, 5)
	if (start >= end) {
		if (target > A[start]) {
			return start + 1;
		} else {
			return start;
		}
	}
	int mid = (start + end)>>1; 
	if (A[mid] == target) {
		return mid;
	} else if (A[mid] < target){
		return searchBinary(A, mid + 1, end, target);
	} else {
		return searchBinary(A, start, mid - 1, target);
	}
}
</pre>
					</li>
				</ul>
			</li>
		</ol>
	</body>
</html>

